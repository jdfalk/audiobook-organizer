// file: internal/database/sqlite_test.go
// version: 1.0.0
// guid: 3c4d5e6f-7a8b-9c0d-1e2f-3a4b5c6d7e8f

package database

import (
	"os"
	"testing"
	"time"

	"github.com/jdfalk/audiobook-organizer/internal/models"
	ulid "github.com/oklog/ulid/v2"
)

func setupTestDB(t *testing.T) (Store, func()) {
	// Create temporary database file
	tmpfile := "/tmp/test_audiobook_" + ulid.Make().String() + ".db"













































































































































































































































































































}	}		t.Errorf("Expected count to increase by 1, got %d -> %d", initialCount, newCount)	if newCount != initialCount+1 {		}		t.Fatalf("Failed to count books after creation: %v", err)	if err != nil {	newCount, err := store.CountBooks()		}		t.Fatalf("Failed to create book: %v", err)	if err != nil {	_, err = store.CreateBook(book)	}		FilePath: "/test/path/book.mp3",		Title:    "Test Count",	book := &Book{	// Create a book		}		t.Fatalf("Failed to count books: %v", err)	if err != nil {	initialCount, err := store.CountBooks()		defer cleanup()	store, cleanup := setupTestDB(t)func TestCountBooks(t *testing.T) {}	}		t.Error("Expected same author ID for duplicate name")	if author1.ID != author2.ID {		}		t.Fatalf("Failed to get existing author: %v", err)	if err != nil {	author2, err := store.GetOrCreateAuthor("New Author")	// Second call should return existing		}		t.Fatalf("Failed to get or create author: %v", err)	if err != nil {	author1, err := store.GetOrCreateAuthor("New Author")	// First call should create		defer cleanup()	store, cleanup := setupTestDB(t)func TestGetOrCreateAuthor(t *testing.T) {}	}		t.Errorf("Expected name 'J.R.R. Tolkien', got '%s'", retrievedAuthor.Name)	if retrievedAuthor.Name != "J.R.R. Tolkien" {		}		t.Fatalf("Failed to get author: %v", err)	if err != nil {	retrievedAuthor, err := store.GetAuthorByID(createdAuthor.ID)	// Get author by ID		}		t.Error("Expected non-zero author ID")	if createdAuthor.ID == 0 {		}		t.Fatalf("Failed to create author: %v", err)	if err != nil {	createdAuthor, err := store.CreateAuthor(author)		}		Name: "J.R.R. Tolkien",	author := &Author{		defer cleanup()	store, cleanup := setupTestDB(t)func TestCreateAndGetAuthor(t *testing.T) {}	}		t.Error("No primary version found")	if !foundPrimary {	}		}			}				t.Error("Wrong book marked as primary")			if v.ID != createdBook1.ID {			foundPrimary = true		if v.IsPrimaryVersion != nil && *v.IsPrimaryVersion {	for _, v := range versions {	foundPrimary := false	// Verify primary version		}		t.Errorf("Expected 2 versions, got %d", len(versions))	if len(versions) != 2 {		}		t.Fatalf("Failed to get books by version group: %v", err)	if err != nil {	versions, err := store.GetBooksByVersionGroup(groupID)	// Get books by version group		}		t.Fatalf("Failed to update book 2 with version group: %v", err)	if err != nil {	_, err = store.UpdateBook(createdBook2.ID, createdBook2)		createdBook2.IsPrimaryVersion = &isPrimaryFalse	isPrimaryFalse := false	createdBook2.VersionGroupID = &groupID		}		t.Fatalf("Failed to update book 1 with version group: %v", err)	if err != nil {	_, err = store.UpdateBook(createdBook1.ID, createdBook1)		createdBook1.IsPrimaryVersion = &isPrimary	isPrimary := true	createdBook1.VersionGroupID = &groupID	groupID := ulid.Make().String()	// Link books as versions		}		t.Fatalf("Failed to create book 2: %v", err)	if err != nil {	createdBook2, err := store.CreateBook(book2)	}		FilePath: "/test/path/book_v2.mp3",		Title:    "Book Version 2",	book2 := &Book{		}		t.Fatalf("Failed to create book 1: %v", err)	if err != nil {	createdBook1, err := store.CreateBook(book1)	}		FilePath: "/test/path/book_v1.mp3",		Title:    "Book Version 1",	book1 := &Book{	// Create two books		defer cleanup()	store, cleanup := setupTestDB(t)func TestVersionManagement(t *testing.T) {}	}		t.Errorf("Expected 5 books, got %d", len(books))	if len(books) != 5 {		}		t.Fatalf("Failed to list books: %v", err)	if err != nil {	books, err := store.ListBooks(10, 0)	// List books with pagination		}		}			t.Fatalf("Failed to create book %d: %v", i, err)		if err != nil {		_, err := store.CreateBook(book)		}			FilePath: "/test/path/book" + string(rune('A'+i)) + ".mp3",			Title:    "Book " + string(rune('A'+i)),		book := &Book{	for i := 0; i < 5; i++ {	// Create multiple books		defer cleanup()	store, cleanup := setupTestDB(t)func TestListBooks(t *testing.T) {}	}		t.Error("Expected error when getting deleted book")	if err == nil {	_, err = store.GetBookByID(createdBook.ID)	// Verify deletion		}		t.Fatalf("Failed to delete book: %v", err)	if err != nil {	err = store.DeleteBook(createdBook.ID)	// Delete the book		}		t.Fatalf("Failed to create book: %v", err)	if err != nil {	createdBook, err := store.CreateBook(book)		}		FilePath: "/test/path/book.mp3",		Title:    "Book to Delete",	book := &Book{	// Create test book		defer cleanup()	store, cleanup := setupTestDB(t)func TestDeleteBook(t *testing.T) {}	}		t.Error("Narrator not updated correctly")	if updatedBook.Narrator == nil || *updatedBook.Narrator != "Test Narrator" {		}		t.Errorf("Expected title 'Updated Title', got '%s'", updatedBook.Title)	if updatedBook.Title != "Updated Title" {		}		t.Fatalf("Failed to update book: %v", err)	if err != nil {	updatedBook, err := store.UpdateBook(createdBook.ID, createdBook)		createdBook.Narrator = &narrator	narrator := "Test Narrator"	createdBook.Title = "Updated Title"	// Update the book		}		t.Fatalf("Failed to create book: %v", err)	if err != nil {	createdBook, err := store.CreateBook(book)		}		FilePath: "/test/path/book.mp3",		Title:    "Original Title",	book := &Book{	// Create test book		defer cleanup()	store, cleanup := setupTestDB(t)func TestUpdateBook(t *testing.T) {}	}		t.Error("Author ID mismatch")	if retrievedBook.AuthorID == nil || *retrievedBook.AuthorID != *book.AuthorID {		}		t.Errorf("Expected title 'Test Book', got '%s'", retrievedBook.Title)	if retrievedBook.Title != "Test Book" {		}		t.Fatalf("Failed to get book: %v", err)	if err != nil {	retrievedBook, err := store.GetBookByID(createdBook.ID)	// Retrieve the book		}		t.Error("Expected non-empty book ID")	if createdBook.ID == "" {		}		t.Fatalf("Failed to create book: %v", err)	if err != nil {	createdBook, err := store.CreateBook(book)		}		FilePath: "/test/path/book.mp3",		AuthorID: &createdAuthor.ID,		Title:    "Test Book",	book := &Book{	// Create test book		}		t.Fatalf("Failed to create author: %v", err)	if err != nil {	createdAuthor, err := store.CreateAuthor(author)	}		Name: "Test Author",	author := &Author{	// Create test author		defer cleanup()	store, cleanup := setupTestDB(t)func TestCreateAndGetBook(t *testing.T) {}	}		t.Fatal("Expected non-nil store")	if store == nil {		defer cleanup()	store, cleanup := setupTestDB(t)func TestNewSQLiteStore(t *testing.T) {}	return store, cleanup		}		os.Remove(tmpfile)		store.Close()	cleanup := func() {		}		t.Fatalf("Failed to create test database: %v", err)	if err != nil {	store, err := NewSQLiteStore(tmpfile)
